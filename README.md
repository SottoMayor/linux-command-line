# Personal Linux Command Line Docs - Bash

## Basic Informations

### Commands

* A **Full Command** consists of:  
`Command + Option(s) + Argument(s)`

* The most important part of a Full Command is the **Command** itself. Options and Arguments complement it.   
`ls` → Full Command generated by a Command.   
`ls -l -a` → Full Command generated by a Command + Options.   

* Below, these three are equivalent, and in the 2nd and 3rd cases, the order doesn't matter:  
`ls -l -a` = `ls -la` = `ls -al`   

From now on, let's refer to a 'Full Command' simply as 'Command', since there is no risk of confusion.

### Terminal

* **Home directory**: Since we opened the Terminal and the `~` is displayed on the screen, we are in the home directory.

## Write commands in a shell at the prompt

`ls`

`ls -l`

`ls -al`

`clear` -> clear the terminal

## Finding help for commands

**`man [command]`** -> `man ls`   
If we press `/`and enter what behavior we want to get, it tries to find in the list of options   
`man ls [Enter] /comma separed [Enter] it should find if the search term matchs with any option description` 

**`[command] --help`** -> `ls --help`

**`apropos [supposed command]`** -> `apropos list`   
**`apropos "[what the command suppose to do]"`** -> using double quotes we can get an exactly match


## TAB (key) completion

1. completes a file or folder name   
2. makes guesses
   
`ls -l De` followed by the Tab key

`ls -l Do` followed by the Tab key twice

`ls -l Doc` followed by the Tab key

`a` followed by the Tab key

## Helpful keyboard shortcuts

| key combination | result |
|-----------------|---------|
| CRTL + A | Move to beginning of line| 
| CRTL + E | Move to end of line|
| arrows | Move letter by letter|
| CRTL + -> | Move left one word | 
| CRTL + <- | Move right one word |
| CRTL + U | Delete from cursor to line start |
| CRTL + K | Delete from cursor to line end |
| CRTL + SHIFT + C | Copy |
| CRTL + SHIFT + V | Paste |
| (up + down) arrow | courses previous commands |
| CRTL + R | Search command history |
| CRTL + C | Cancel command |
| CRTL + L | Clear the terminal |



## File system

1. Absolute path: starts with `/`for the file system root.
2. Relative path: does not.

**`file [document]`** -> Determinates the file type

**`stat [document]`** -> display the file or file system status

## Navigating the file system

**`cd`** -> Change Directory
**`pwd`** -> Print Working Directory

Go to Document folder and print the current working directory:
`cd Documents/` 
`pwd`

Using `cd`with directories with blanks:   
1. Invalid command
`cd Exercise Files`   
2. Valid commands possibilities:
2.1: Using double quotes   
    `cd "Exercise Files"`
2.2: Using scape (commom usage)
   `cd Exercise\ Files`

Listen files recursively:   
`ls -R departments/`   

Single dot:   
`.`-> represents the current working directory

Navigation between directories:  
1. `cd departments/hr/policies` -> go to `departments/hr/policies` directory   
2. `cd ..` -> up one level = `departments/hr`   
3. `cd ..` -> up (more) one level = `departments`   
4. `cd hr/policies` -> down two levels in a row = `departments/hr/policies`   
5. `cd ../../finance/documents` -> down two levels in a row, enter in finance after documents = `departments/finance/documents`   
6. `cd -` -> Back and forth between the previous and current directories   
7. `cd` -> back to the home directory

## ls command, one of the most useful commands

`ls`

`ls --color=always` -> helpful to represent differents aspects of files

`ls -l` -> use a long listing format (see metadata)

`ls -lh` -> see metadata in human readable way, helpful to verify file sizes.

## Create and remove directories

Suppose a pre-existing `departments`folder...  

1. **Create**

- `mkdir newfolder` -> creates a new folder `newfolder`    

- `mkdir departments/customerservice` -> inside `departments` creates the `customerservice`

- `mkdir departments/customerservice/documents departments/customerservice/cases departments/customerservice/awards` -> creates more than 1 folder at once

- `mkdir -p departments/legal/contracts` -> With the `-p`, creates a folder and parent folder at once

2. **Remove**

- `rmdir departments/legal/contracts/` -> Removes folders. This removal is only allowed if the folder is empty.

- `rmdir departments/legal/` -> removes the `legal` folder


## Copy, move, and delete files and directories
1. **Copy**: `cp [file] [directory to copy and new name (optional)]`  
   - `cp poems.txt poems2.txt` -> copy the poems.txt file to the same directory and set the copy name as `poems2.txt`
   - `cp simple_data.txt departments/hr/employee\ info/` -> copy the poems.txt file to the directory `departments/hr/employee\ info`
   - `cp simple_data.txt departments/new.txt` -> copy the poems.txt file to the directory `departments` and set the copy name as `new.txt`

2. **Move**: 
   1. **Move a file**: `mv [file] [directory]`   
      `mv poems2.txt departments/marketing`   
   2. **Rename a file**: `mv [file] [same directory as the file + new name]`   
      `mv departments/marketing/poems2.txt departments/marketing/literature.txt`
      
      Suppose you are in the `documents` directory and exists the `departments/marketing/literature.txt`subdirectory:
      
      `mv departments/marketing/literature.txt .` -> moves the `literature.txt`file to the current directory (`documents`, in this case).

      `mv *.txt departments/marketing/` -> moves all files of the directory with .txt extension to `departments/marketing/`
      `mv departments/marketing/* .` -> moves all files of the `departments/marketing/` directory to the current directory.


3. **Remove**: `rm [file]` -> Warning: There is no chance to undo!   
`rm literature.txt`

Removing recursively:   
`rm -r departments/customerservice/`   



## Command find, basic usage

_consult the man to more infos about this command_

1. Relative path:   
   `find . -name "poe*"` -> finds in the current directory, by name, all files that starts with "poe".
   
2. Absolute path:   
`find ~/Documents -name "*d*"` -> finds in the Documents directory, by name, all files that contains the caracther "d".


`find / -name "filename"` -> Searches recursively for files named 'filename' starting from the root directory.

## The sudo

_sudo means Super User DO_ 

usage -> `sudo [Full Command]`

A commum user can not access:   
`ls /root`

The sudo can access:  
`sudo ls /root`

Removing the sudo privelegies of the user:   
`sudo -k`

Starts an interactive shell as root:   
`sudo -s`

## Links

`ln -s(optional) [target file] [link name]`   

- soft (symbolic) link: points to another file, relative path   
- Hard link: points to a specific data on the disk, absolute path   

_OBS_: Both breaks if the original file is moved away.   

file points to another file, uses the -s option (view infos with `ls -l`):   
`ln -s poems.txt writing.txt` -> creating the soft link writing.txt to the file poems.txt   

`cat writing.txt` -> printing the file output   

file points to the data of the disk, ommit the -s option (view infos with `ls -l`):   
`ln poems.txt words.txt`

## Pipes

pipe: `|`-> takes the output of one command and send it to another. The order matters!   

- echo: prints out the argument.   
`echo "Hello"`

- wc: print newline, word, and byte counts for each file.

- Combining echo + wc in one go with the help of pipe:   
1.`echo "Hello" | wc`   
2.`echo "Hello world from the command line" | wc`

## View text files

1. cat -> _Concatenate_ files and print on the standard output   
`cat poems.txt`

We can enumarate lines with this command   
`cat -n poems.txt`

2. head -> output the first part of files   
`head poems.txt`

We can configure the number of lines to be displayed   
`head -n5 poems.txt`

3. tail -> output the last part of files   
`tail -n3 poems.txt`


We can combine them with pipes! And remember, the order matters.

- `cat poems.txt | cat -n | tail -n5`   

- `cat poems.txt | tail -n5 | cat -n`

- `less poems.txt`

- `cat poems.txt | less`

## Search for text in files and streams with grep

- It is case sensitive by default.   

`grep "the" poems.txt` -> searches by a search term.

`grep -n "the" poems.txt` -> searches by term and using the line count output (`-n`)

`grep -in "The" poems.txt` -> searches considering case insensitive and line count (`-in`)

`grep -vi "the" poems.txt` -> searches considering case insensitive ant to ommit the lines that matches the search term (`-vi`)

Using regex (`-E`):
`grep -E "\w{6.}" poems.txt` -> Get the lines that have words with at least 6 characters.

## Manipulate text with awk, sed, and sort

1. `awk`:
   - extract specific text from a file.   
   - written at the command line or stored in a file.   
2. `sed`:   
   - **S**tream **ed**itor.   
   - Modifynig text in a command line or in place in a file.   

-`awk`:   
Suppose a text file, like a positional file, named simple_data.txt:   
`cat simple_data.txt`

Right after `awk`declaration comes the _awk program_, between single quotes:   
`awk '{print $2}' simple_data.txt` -> show only the 2 column of this file.

We can scape inside awk programs, `"\t"` is a tab character:   
`awk '{print $2 "\t" $1}' simple_data.txt` -> show the 2 column, give a tab and show the 1 column.

We can use pipes also, `sort -n` makes a numeric sort:    
`awk '{print $2 "\t" $1}' simple_data.txt | sort -n` -> Do the same as above and, in the end, provides a numeric sort (in this file in particular, order by a the ID column).

-`sed`:
We can substitute words by another words:   
`sed s/Orange/Red/ simple_data.txt` -> substitutes "Orange" by "Red".   

-`sort` -> sort line of text:
`sort simple_data.txt` -> Sort by the first column by default.   

We can provide the column to perform the sort.   
`sort -k2 simple_data.txt` -> Do the sort using the second column.   
`sort -k2 -n simple_data.txt` -> Do the sort using the second column, if this column is numeric.   

We can ignore duplicates, `-u` gets only unique lines:   
`sort -u dupes.txt`   

## Working with tar and zip archives

**tar**:   
- **T**ape **ar**chives (format: .tar).   
- Put many files together inside one file.   
- Data compression is optional (formats: .tar.gz, .tgz, ...).   
- Command: `tar [options] [tar filename] [directory or files to include in the archive]`

Create a regular tar archive:   
`tar -cvf myfiles.tar Exercise\ Files/` -> `-c` = create an archive | `-v` = verbose | `-f` = output the archive to a file.

`tar -caf myfiles.tar.gz Exercise\ Files/` -> `-a` = let tar figure out what kind of compression to use, based on the file extension.   

Extracting an archive:   
`tar -xf myfiles.tar.gz`

Extract a file into a folder:   
1- create the folder:   
`mkdir unpack2`   
2 - Extract the file:   
`tar -xf myfiles.tar.gz -C unpack2` -> `-C` = directory to extract the file.   


**zip**:   
- More cross platform friendly.   
- You might need to install depending on your distro.  
- Command: `zip [options] [zip filename].zip [directory or files to zip]`   

Zip files:    
`zip -r exfiles.zip Exercise\ Files/`   

Unzip (extract) files:     
`unzip exfiles.zip`   

Unzip (extract) a file into a folder:   
1- create the folder:   
`mkdir unpack4`   
2 - Extract the file:   
`unzip exfiles.zip -d unpack4` -> `-d` = destination directory.   


## Environment variables and PATH

`env` -> List the system's path.   

`echo $PATH` -> displays the value on PATH env var.   

## Linux distribution information 

View infos in short-hand way:   
`cat /etc/lsb-release`

View infos in more detailed way:   
`cat /etc/os-release`

View infos in these two ways at once:   
`cat /etc/*release`

View Linux Kernel informations:   
`uname -a` -> View all informations   
`uname -r` -> View only the version of the Kernel.  

## 05_03 - Install and update software with a package manager

Checks if everything is up to date  (interesting running before install any package):   
`sudo apt update`   

Installs a package:   
`sudo apt install tree`   

Installs new versions of packages:   
`sudo apt upgrade`
